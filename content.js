// YouTube Transcript Extractor - Content Script
console.log("YouTube Transcript Extractor loaded");

class YouTubeTranscriptExtractor {
  constructor() {
    this.currentVideoId = null;
    this.captionTracks = [];
    this.setupMessageListener();
    this.injectTranscriptCapture();
    this.setupTranscriptListener();
  }

  setupMessageListener() {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      if (request.action === "getVideoInfo") {
        this.handleGetVideoInfo(sendResponse);
        return true; // Will respond asynchronously
      } else if (request.action === "fetchTranscript") {
        this.handleFetchTranscript(request.captionTrack, sendResponse);
        return true; // Will respond asynchronously
      }
    });
  }

  // Inject script into page context to run before YouTube's scripts
  injectTranscriptCapture() {
    console.log("ðŸš€ Injecting transcript capture script...");

    const script = document.createElement("script");
    script.src = chrome.runtime.getURL("inject.js");

    // Inject into head as early as possible
    (document.head || document.documentElement).appendChild(script);

    console.log("âœ… Transcript capture script injected");
  }

  // Listen for transcript capture events from injected script
  setupTranscriptListener() {
    document.addEventListener("youtubeTranscriptCaptured", (event) => {
      console.log("ðŸ“¡ Received transcript capture event:", event.detail);
      this.handleCapturedTranscript(event.detail);
    });
  }

  // Process captured transcript from injected script
  async handleCapturedTranscript(captureData) {
    try {
      const { url, response } = captureData;

      console.log("ðŸ” Processing captured transcript:", url);

      if (!response || response.trim() === "") {
        console.log("âŒ Empty response received");
        return;
      }

      // Parse the JSON response
      const jsonData = JSON.parse(response);
      const parsedTranscript = this.parseTranscriptJSON(jsonData);

      if (parsedTranscript.length > 0) {
        console.log(
          "âœ… Successfully parsed transcript with",
          parsedTranscript.length,
          "segments"
        );

        // Format transcript
        const formattedTranscript = this.formatTranscript(
          parsedTranscript,
          false
        );
        const timestampedTranscript = this.formatTranscript(
          parsedTranscript,
          true
        );

        // Determine language and type from URL
        const urlObj = new URL(url);
        const lang = urlObj.searchParams.get("lang") || "en";
        const isAutoGenerated = urlObj.searchParams.get("kind") === "asr";

        // Send to background service worker
        chrome.runtime.sendMessage({
          action: "transcriptCaptured",
          data: {
            transcript: formattedTranscript,
            timestampedTranscript: timestampedTranscript,
            segments: parsedTranscript,
            language: lang,
            isAutoGenerated: isAutoGenerated,
            wordCount: formattedTranscript.split(" ").length,
            captureMethod: "Auto-capture (Injected Script)",
          },
        });
      } else {
        console.log("âŒ No transcript segments found in response");
      }
    } catch (error) {
      console.error("âŒ Error processing captured transcript:", error);
    }
  }

  // Extract video ID from current YouTube URL
  getVideoId() {
    const urlParams = new URLSearchParams(window.location.search);
    const videoId = urlParams.get("v");

    if (!videoId && window.location.pathname.startsWith("/watch")) {
      // Fallback for edge cases
      return null;
    }

    return videoId;
  }

  // Get video title from page
  getVideoTitle() {
    // Try multiple selectors as YouTube's DOM can vary
    const selectors = [
      "h1.ytd-watch-metadata #title",
      "h1.title yt-formatted-string",
      ".watch-main-col .watch-title",
      'h1[class*="title"]',
    ];

    for (const selector of selectors) {
      const titleElement = document.querySelector(selector);
      if (titleElement && titleElement.textContent.trim()) {
        return titleElement.textContent.trim();
      }
    }

    return "YouTube Video";
  }

  // Extract caption tracks from ytInitialPlayerResponse
  getCaptionTracks() {
    try {
      // First try to get from window objects
      let playerResponse = null;

      if (window.ytInitialPlayerResponse) {
        playerResponse = window.ytInitialPlayerResponse;
      } else {
        // Try to extract from script tags
        const scripts = document.querySelectorAll("script");
        for (const script of scripts) {
          const content = script.textContent;
          if (content && content.includes("ytInitialPlayerResponse")) {
            const match = content.match(
              /ytInitialPlayerResponse\s*[=:]\s*({.+?});/
            );
            if (match) {
              playerResponse = JSON.parse(match[1]);
              break;
            }
          }
        }
      }

      if (!playerResponse || !playerResponse.captions) {
        return [];
      }

      // cSpell:ignore Tracklist
      const captionRenderer =
        playerResponse.captions.playerCaptionsTracklistRenderer;
      if (!captionRenderer || !captionRenderer.captionTracks) {
        return [];
      }

      return captionRenderer.captionTracks.map((track) => ({
        baseUrl: track.baseUrl,
        languageCode: track.languageCode,
        name: track.name?.simpleText || track.languageCode,
        kind: track.kind || "manual", // 'asr' for auto-generated, undefined/manual for uploaded
        isAutoGenerated: track.kind === "asr",
      }));
    } catch (error) {
      console.error("Error extracting caption tracks:", error);
      return [];
    }
  }

  // Handle request for video information
  async handleGetVideoInfo(sendResponse) {
    try {
      const videoId = this.getVideoId();
      if (!videoId) {
        sendResponse({
          success: false,
          error:
            "No video ID found. Please make sure you are on a YouTube video page.",
        });
        return;
      }

      const title = this.getVideoTitle();
      const captionTracks = this.getCaptionTracks();

      this.currentVideoId = videoId;
      this.captionTracks = captionTracks;

      sendResponse({
        success: true,
        data: {
          videoId,
          title,
          captionTracks,
          hasTranscripts: captionTracks.length > 0,
        },
      });
    } catch (error) {
      console.error("Error getting video info:", error);
      sendResponse({
        success: false,
        error: "Failed to extract video information: " + error.message,
      });
    }
  }

  // Parse JSON transcript response (YouTube's newer format)
  parseTranscriptJSON(jsonData) {
    try {
      const transcript = [];

      // YouTube's JSON3 format has events array
      if (jsonData.events) {
        jsonData.events.forEach((event) => {
          // cSpell:ignore segs
          if (event.segs) {
            // Each event has segments (segs) with text
            const eventStart = event.tStartMs / 1000; // Convert from milliseconds
            const eventDuration = (event.dDurationMs || 0) / 1000;

            let eventText = "";
            event.segs.forEach((seg) => {
              if (seg.utf8) {
                eventText += seg.utf8;
              }
            });

            if (eventText.trim()) {
              transcript.push({
                text: this.decodeHTMLEntities(eventText.trim()),
                start: eventStart,
                duration: eventDuration,
                end: eventStart + eventDuration,
              });
            }
          }
        });
      }

      return transcript;
    } catch (error) {
      console.error("Error parsing transcript JSON:", error);
      throw new Error("Failed to parse transcript JSON");
    }
  }

  // Parse XML transcript response (fallback for older format)
  parseTranscriptXML(xmlString) {
    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "text/xml");
      const textElements = xmlDoc.querySelectorAll("text");

      const transcript = [];
      textElements.forEach((element) => {
        const text = element.textContent.trim();
        const start = parseFloat(element.getAttribute("start") || "0");
        const duration = parseFloat(element.getAttribute("dur") || "0");

        if (text) {
          transcript.push({
            text: this.decodeHTMLEntities(text),
            start: start,
            duration: duration,
            end: start + duration,
          });
        }
      });

      return transcript;
    } catch (error) {
      console.error("Error parsing transcript XML:", error);
      throw new Error("Failed to parse transcript XML");
    }
  }

  // Decode HTML entities in transcript text
  decodeHTMLEntities(text) {
    const textarea = document.createElement("textarea");
    textarea.innerHTML = text;
    return textarea.value;
  }

  // Format transcript for display
  formatTranscript(transcript, includeTimestamps = false) {
    if (includeTimestamps) {
      return transcript
        .map((segment) => {
          const minutes = Math.floor(segment.start / 60);
          const seconds = Math.floor(segment.start % 60);
          const timestamp = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          return `[${timestamp}] ${segment.text}`;
        })
        .join("\n");
    } else {
      return transcript.map((segment) => segment.text).join(" ");
    }
  }

  // Handle request to fetch transcript
  async handleFetchTranscript(captionTrack, sendResponse) {
    try {
      if (!captionTrack || !captionTrack.baseUrl) {
        throw new Error("Invalid caption track provided");
      }

      // Use the original baseUrl with minimal modifications
      // Keep existing auth parameters, only ensure JSON format
      const urlObj = new URL(captionTrack.baseUrl);
      if (!urlObj.searchParams.has("fmt")) {
        urlObj.searchParams.set("fmt", "json3");
      }

      const transcriptUrl = urlObj.toString();
      console.log("Fetching transcript from:", transcriptUrl);

      const response = await fetch(transcriptUrl);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseText = await response.text();
      console.log(
        "Response content (first 200 chars):",
        responseText.substring(0, 200)
      );

      // Try to parse as JSON first (YouTube's new format)
      let parsedTranscript;
      try {
        const jsonData = JSON.parse(responseText);
        parsedTranscript = this.parseTranscriptJSON(jsonData);
      } catch (jsonError) {
        // Fallback to XML parsing
        console.log("JSON parsing failed, trying XML:", jsonError);
        parsedTranscript = this.parseTranscriptXML(responseText);
      }

      if (parsedTranscript.length === 0) {
        throw new Error("No transcript content found");
      }

      const formattedTranscript = this.formatTranscript(
        parsedTranscript,
        false
      );
      const timestampedTranscript = this.formatTranscript(
        parsedTranscript,
        true
      );

      sendResponse({
        success: true,
        data: {
          transcript: formattedTranscript,
          timestampedTranscript: timestampedTranscript,
          segments: parsedTranscript,
          language: captionTrack.name,
          isAutoGenerated: captionTrack.isAutoGenerated,
          wordCount: formattedTranscript.split(" ").length,
        },
      });
    } catch (error) {
      console.error("Error fetching transcript:", error);
      sendResponse({
        success: false,
        error: "Failed to fetch transcript: " + error.message,
      });
    }
  }
}

// Initialize the extractor when the script loads
const transcriptExtractor = new YouTubeTranscriptExtractor();

// Listen for navigation changes using History API (more efficient than MutationObserver)
let lastUrl = location.href;

// Hook into History API for SPA navigation detection
const originalPushState = history.pushState;
const originalReplaceState = history.replaceState;

history.pushState = function (...args) {
  originalPushState.apply(history, args);
  checkUrlChange();
};

history.replaceState = function (...args) {
  originalReplaceState.apply(history, args);
  checkUrlChange();
};

// Also listen for popstate events
window.addEventListener("popstate", checkUrlChange);

function checkUrlChange() {
  const currentUrl = location.href;
  if (currentUrl !== lastUrl) {
    lastUrl = currentUrl;
    // Reset state when navigating to a new video
    transcriptExtractor.currentVideoId = null;
    transcriptExtractor.captionTracks = [];
    console.log("YouTube navigation detected, state reset");
  }
}
