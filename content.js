// YouTube Transcript Extractor - Content Script
console.log("YouTube Transcript Extractor loaded");

class YouTubeTranscriptExtractor {
  constructor() {
    this.currentVideoId = null;
    this.captionTracks = [];
    this.setupMessageListener();
    this.injectTranscriptCapture();
    this.setupTranscriptListener();
  }

  setupMessageListener() {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      if (request.action === "getVideoInfo") {
        this.handleGetVideoInfo(sendResponse);
        return true; // Will respond asynchronously
      } else if (request.action === "fetchTranscript") {
        this.handleFetchTranscript(request.captionTrack, sendResponse);
        return true; // Will respond asynchronously
      }
    });
  }

  // Inject script into page context to run before YouTube's scripts
  injectTranscriptCapture() {
    console.log("🚀 Injecting transcript capture script...");

    const script = document.createElement("script");
    script.src = chrome.runtime.getURL("inject.js");

    // Inject into head as early as possible
    (document.head || document.documentElement).appendChild(script);

    console.log("✅ Transcript capture script injected");
  }

  // Listen for transcript capture events from injected script
  setupTranscriptListener() {
    document.addEventListener("youtubeTranscriptCaptured", (event) => {
      console.log("📡 Received transcript capture event:", event.detail);
      this.handleCapturedTranscript(event.detail);
    });
  }

  // Process captured transcript from injected script
  async handleCapturedTranscript(captureData) {
    try {
      const { url, response } = captureData;

      console.log("🔍 Processing captured transcript:", url);

      if (!response || response.trim() === "") {
        console.log("❌ Empty response received");
        return;
      }

      // Parse the JSON response
      const jsonData = JSON.parse(response);
      const parsedTranscript = this.parseTranscriptJSON(jsonData);

      if (parsedTranscript.length > 0) {
        console.log(
          "✅ Successfully parsed transcript with",
          parsedTranscript.length,
          "segments"
        );

        // Format transcript
        const formattedTranscript = this.formatTranscript(
          parsedTranscript,
          false
        );
        const timestampedTranscript = this.formatTranscript(
          parsedTranscript,
          true
        );

        // Determine language and type from URL
        const urlObj = new URL(url);
        const lang = urlObj.searchParams.get("lang") || "en";
        const isAutoGenerated = urlObj.searchParams.get("kind") === "asr";

        // Send to background service worker
        chrome.runtime.sendMessage({
          action: "transcriptCaptured",
          data: {
            transcript: formattedTranscript,
            timestampedTranscript: timestampedTranscript,
            segments: parsedTranscript,
            language: lang,
            isAutoGenerated: isAutoGenerated,
            wordCount: formattedTranscript.split(" ").length,
            captureMethod: "Auto-capture (Injected Script)",
          },
        });
      } else {
        console.log("❌ No transcript segments found in response");
      }
    } catch (error) {
      console.error("❌ Error processing captured transcript:", error);
    }
  }

  // Extract video ID from current YouTube URL
  getVideoId() {
    const urlParams = new URLSearchParams(window.location.search);
    const videoId = urlParams.get("v");

    if (!videoId && window.location.pathname.startsWith("/watch")) {
      // Fallback for edge cases
      return null;
    }

    return videoId;
  }

  // Get video title from page
  getVideoTitle() {
    // Try multiple selectors as YouTube's DOM can vary
    const selectors = [
      "h1.ytd-watch-metadata #title",
      "h1.title yt-formatted-string",
      ".watch-main-col .watch-title",
      'h1[class*="title"]',
    ];

    for (const selector of selectors) {
      const titleElement = document.querySelector(selector);
      if (titleElement && titleElement.textContent.trim()) {
        return titleElement.textContent.trim();
      }
    }

    return "YouTube Video";
  }

  // Extract caption tracks from ytInitialPlayerResponse
  getCaptionTracks() {
    try {
      // First try to get from window objects
      let playerResponse = null;

      if (window.ytInitialPlayerResponse) {
        playerResponse = window.ytInitialPlayerResponse;
      } else {
        // Try to extract from script tags
        const scripts = document.querySelectorAll("script");
        for (const script of scripts) {
          const content = script.textContent;
          if (content && content.includes("ytInitialPlayerResponse")) {
            const match = content.match(
              /ytInitialPlayerResponse\s*[=:]\s*({.+?});/
            );
            if (match) {
              playerResponse = JSON.parse(match[1]);
              break;
            }
          }
        }
      }

      if (!playerResponse || !playerResponse.captions) {
        return [];
      }

      // cSpell:ignore Tracklist
      const captionRenderer =
        playerResponse.captions.playerCaptionsTracklistRenderer;
      if (!captionRenderer || !captionRenderer.captionTracks) {
        return [];
      }

      return captionRenderer.captionTracks.map((track) => ({
        baseUrl: track.baseUrl,
        languageCode: track.languageCode,
        name: track.name?.simpleText || track.languageCode,
        kind: track.kind || "manual", // 'asr' for auto-generated, undefined/manual for uploaded
        isAutoGenerated: track.kind === "asr",
      }));
    } catch (error) {
      console.error("Error extracting caption tracks:", error);
      return [];
    }
  }

  // Handle request for video information
  async handleGetVideoInfo(sendResponse) {
    try {
      const videoId = this.getVideoId();
      if (!videoId) {
        sendResponse({
          success: false,
          error:
            "No video ID found. Please make sure you are on a YouTube video page.",
        });
        return;
      }

      const title = this.getVideoTitle();
      const captionTracks = this.getCaptionTracks();

      this.currentVideoId = videoId;
      this.captionTracks = captionTracks;

      sendResponse({
        success: true,
        data: {
          videoId,
          title,
          captionTracks,
          hasTranscripts: captionTracks.length > 0,
        },
      });
    } catch (error) {
      console.error("Error getting video info:", error);
      sendResponse({
        success: false,
        error: "Failed to extract video information: " + error.message,
      });
    }
  }

  // Parse JSON transcript response (YouTube's newer format)
  parseTranscriptJSON(jsonData) {
    try {
      const transcript = [];

      // YouTube's JSON3 format has events array
      if (jsonData.events) {
        jsonData.events.forEach((event) => {
          // cSpell:ignore segs
          if (event.segs) {
            // Each event has segments (segs) with text
            const eventStart = event.tStartMs / 1000; // Convert from milliseconds
            const eventDuration = (event.dDurationMs || 0) / 1000;

            let eventText = "";
            event.segs.forEach((seg) => {
              if (seg.utf8) {
                eventText += seg.utf8;
              }
            });

            if (eventText.trim()) {
              transcript.push({
                text: this.decodeHTMLEntities(eventText.trim()),
                start: eventStart,
                duration: eventDuration,
                end: eventStart + eventDuration,
              });
            }
          }
        });
      }

      return transcript;
    } catch (error) {
      console.error("Error parsing transcript JSON:", error);
      throw new Error("Failed to parse transcript JSON");
    }
  }

  // Parse XML transcript response (fallback for older format)
  parseTranscriptXML(xmlString) {
    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "text/xml");
      const textElements = xmlDoc.querySelectorAll("text");

      const transcript = [];
      textElements.forEach((element) => {
        const text = element.textContent.trim();
        const start = parseFloat(element.getAttribute("start") || "0");
        const duration = parseFloat(element.getAttribute("dur") || "0");

        if (text) {
          transcript.push({
            text: this.decodeHTMLEntities(text),
            start: start,
            duration: duration,
            end: start + duration,
          });
        }
      });

      return transcript;
    } catch (error) {
      console.error("Error parsing transcript XML:", error);
      throw new Error("Failed to parse transcript XML");
    }
  }

  // Extract POT (Proof of Origin Token) from YouTube page data
  extractPotToken() {
    try {
      console.log("Starting POT token extraction...");

      // Try to find pot token in ytInitialPlayerResponse first
      if (window.ytInitialPlayerResponse) {
        const playerResponse = window.ytInitialPlayerResponse;
        console.log("Checking ytInitialPlayerResponse for POT token...");

        // Check if pot token exists in captions renderer
        if (
          playerResponse.captions &&
          playerResponse.captions.playerCaptionsTracklistRenderer &&
          playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks
        ) {
          const tracks =
            playerResponse.captions.playerCaptionsTracklistRenderer
              .captionTracks;
          for (const track of tracks) {
            if (track.baseUrl) {
              const url = new URL(track.baseUrl);
              const pot = url.searchParams.get("pot");
              if (pot) {
                console.log(
                  "✓ Found POT token in caption track baseUrl:",
                  pot.substring(0, 20) + "..."
                );
                return pot;
              }
            }
          }
        }

        // Deep search in playerResponse for pot tokens
        const responseStr = JSON.stringify(playerResponse);
        console.log("Searching playerResponse JSON string for POT patterns...");

        // Try multiple patterns for pot token
        const potPatterns = [
          /["\']pot["\']:\s*["\']([^"']+)["\']/,
          /pot=([^&"'\s]+)/g,
          /pot["\']?\s*[:=]\s*["\']([MN][a-zA-Z0-9+/=_%]{20,})["\']/, // Base64-like pattern starting with M or N
          /"pot":"([^"]+)"/,
          /'pot':'([^']+)'/,
        ];

        for (const pattern of potPatterns) {
          const matches = responseStr.matchAll(pattern);
          for (const match of matches) {
            if (match[1] && match[1].length > 10) {
              console.log(
                "✓ Found POT token in playerResponse:",
                match[1].substring(0, 20) + "..."
              );
              return decodeURIComponent(match[1]);
            }
          }
        }
      }

      // Try to find POT token in ytInitialData
      if (window.ytInitialData) {
        console.log("Checking ytInitialData for POT token...");
        const dataStr = JSON.stringify(window.ytInitialData);
        const potMatch =
          dataStr.match(
            /pot["\']?\s*[:=]\s*["\']([MN][a-zA-Z0-9+/=_%]{20,})["\']/
          ) || dataStr.match(/"pot":"([^"]+)"/);
        if (potMatch) {
          console.log(
            "✓ Found POT token in ytInitialData:",
            potMatch[1].substring(0, 20) + "..."
          );
          return decodeURIComponent(potMatch[1]);
        }
      }

      // Comprehensive search in all page scripts
      console.log("Searching all script tags for POT token...");
      const scripts = document.querySelectorAll("script");
      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];
        if (script.textContent && script.textContent.length > 100) {
          const content = script.textContent;

          // Look for pot parameter patterns with more specific regex
          const potPatterns = [
            /pot["\']?\s*[:=]\s*["\']([MN][a-zA-Z0-9+/=_%]{30,})["\']/, // Long Base64-like starting with M/N
            /pot=([MN][A-Za-z0-9+/=%]{30,})(?:[&"'\s]|$)/, // URL parameter format
            /"pot":"([MN][^"]{20,})"/, // JSON format
            /'pot':'([MN][^']{20,})'/, // Single quotes
          ];

          for (const pattern of potPatterns) {
            const potMatch = content.match(pattern);
            if (potMatch && potMatch[1]) {
              console.log(
                "✓ Found POT token in script tag:",
                potMatch[1].substring(0, 20) + "..."
              );
              return decodeURIComponent(potMatch[1]);
            }
          }
        }
      }

      console.log(
        "❌ POT token not found in any location, proceeding without it"
      );
      return null;
    } catch (error) {
      console.error("Error extracting POT token:", error);
      return null;
    }
  }

  // Decode HTML entities in transcript text
  decodeHTMLEntities(text) {
    const textarea = document.createElement("textarea");
    textarea.innerHTML = text;
    return textarea.value;
  }

  // Format transcript for display
  formatTranscript(transcript, includeTimestamps = false) {
    if (includeTimestamps) {
      return transcript
        .map((segment) => {
          const minutes = Math.floor(segment.start / 60);
          const seconds = Math.floor(segment.start % 60);
          const timestamp = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          return `[${timestamp}] ${segment.text}`;
        })
        .join("\n");
    } else {
      return transcript.map((segment) => segment.text).join(" ");
    }
  }

  // Handle request to fetch transcript
  async handleFetchTranscript(captionTrack, sendResponse) {
    try {
      if (!captionTrack || !captionTrack.baseUrl) {
        throw new Error("Invalid caption track provided");
      }

      // Use the original baseUrl as-is (it contains necessary auth parameters)
      let transcriptUrl = captionTrack.baseUrl;

      // Log the original URL to debug
      console.log("Original baseUrl:", transcriptUrl);

      // Always ensure we request JSON format and add required parameters
      const urlObj = new URL(transcriptUrl);
      if (!urlObj.searchParams.has("fmt")) {
        urlObj.searchParams.set("fmt", "json3");
      }

      // Add additional parameters that YouTube's player uses
      // cSpell:ignore xorb xobt xovt
      if (!urlObj.searchParams.has("xorb")) {
        urlObj.searchParams.set("xorb", "2");
        urlObj.searchParams.set("xobt", "3");
        urlObj.searchParams.set("xovt", "3");
      }

      // Add client parameters
      // cSpell:ignore cver cplayer UNIPLAYER
      if (!urlObj.searchParams.has("c")) {
        urlObj.searchParams.set("c", "WEB");
        urlObj.searchParams.set("cver", "2.20251017.01.00");
        urlObj.searchParams.set("cplayer", "UNIPLAYER");
      }

      // Add device/browser parameters (extracted from working request)
      // cSpell:ignore cbrand cbrver cosver cplatform
      if (!urlObj.searchParams.has("cbrand")) {
        urlObj.searchParams.set("cbrand", "apple");
        urlObj.searchParams.set("cbr", "Chrome");
        urlObj.searchParams.set("cbrver", "140.0.0.0");
        urlObj.searchParams.set("cos", "Macintosh");
        urlObj.searchParams.set("cosver", "10_15_7");
        urlObj.searchParams.set("cplatform", "DESKTOP");
      }

      // Add proof of origin token if not present
      // cSpell:ignore potc
      if (!urlObj.searchParams.has("potc")) {
        urlObj.searchParams.set("potc", "1");

        // Try to extract pot token from the page
        const potToken = this.extractPotToken();
        if (potToken) {
          urlObj.searchParams.set("pot", potToken);
          console.log("Added POT token:", potToken.substring(0, 20) + "...");
        }
      }

      transcriptUrl = urlObj.toString();
      console.log("Enhanced URL with all parameters:", transcriptUrl);

      console.log("Fetching transcript from:", transcriptUrl);

      const response = await fetch(transcriptUrl);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const responseText = await response.text();
      console.log(
        "Response content (first 500 chars):",
        responseText.substring(0, 500)
      );

      // Try to parse as JSON first (YouTube's new format)
      let parsedTranscript;
      try {
        const jsonData = JSON.parse(responseText);
        parsedTranscript = this.parseTranscriptJSON(jsonData);
      } catch (jsonError) {
        // Fallback to XML parsing
        console.log("JSON parsing failed, trying XML:", jsonError);
        parsedTranscript = this.parseTranscriptXML(responseText);
      }

      if (parsedTranscript.length === 0) {
        throw new Error("No transcript content found");
      }

      const formattedTranscript = this.formatTranscript(
        parsedTranscript,
        false
      );
      const timestampedTranscript = this.formatTranscript(
        parsedTranscript,
        true
      );

      sendResponse({
        success: true,
        data: {
          transcript: formattedTranscript,
          timestampedTranscript: timestampedTranscript,
          segments: parsedTranscript,
          language: captionTrack.name,
          isAutoGenerated: captionTrack.isAutoGenerated,
          wordCount: formattedTranscript.split(" ").length,
        },
      });
    } catch (error) {
      console.error("Error fetching transcript:", error);
      sendResponse({
        success: false,
        error: "Failed to fetch transcript: " + error.message,
      });
    }
  }
}

// Initialize the extractor when the script loads
const transcriptExtractor = new YouTubeTranscriptExtractor();

// Also listen for navigation changes (YouTube is a SPA)
let lastUrl = location.href;
new MutationObserver(() => {
  const url = location.href;
  if (url !== lastUrl) {
    lastUrl = url;
    // Reset state when navigating to a new video
    transcriptExtractor.currentVideoId = null;
    transcriptExtractor.captionTracks = [];
    console.log("YouTube navigation detected, state reset");
  }
}).observe(document, { subtree: true, childList: true });
